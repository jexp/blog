== Passt das? Regul√§re Ausdr√ºcke in Java

Nein, es ist kein alter Hut, regul√§re Ausdr√ºcke gibt es zwar schon sehr lange, sie sind aber ein wichtiges Mittel in der Arbeit mit Text.

Mit regul√§ren Ausdr√ºcken kann man komplexe Muster von Textbestandteilen ausdr√ºcken, zum Beispiel `\[[A-Z]\w+\d*\]` f√ºr Referenzen in JavaSpektrum Artikeln, wie [Hun19].

Die Urspr√ºnge liegen bestimmt schon l√§nger zur√ºck, aber mit "regular expression" Notation hatte der Mathematiker Stephen Kleene in 1951 eine n√ºtzliche Form gefunden, komplexe Muster auszudr√ºcken [History].

Eine √§hnliche Notation wurde von Ken Thompson 1968 in den Unix Editor `QED` (sp√§ter `ed`) f√ºr die Suche nach Textstellen integriert, von da aus trat das Konzept seinen Siegeszug durch die Tools (sed, awk, grep, vi) und Programmiersprachen an (Perl, PCRE, Ruby, PHP, Python, Java).

Urspr√ºnglich hatte Java keine Unterst√ºtzung f√ºr regul√§re Ausdr√ºcke, es wurden Bibliotheken wie `regexp` von Jonathan Locke genutzt, diese wurde 2000, an die Apache Foundation [JakartaRegexp] gestiftet.

Mit Java 1.4 wurde Unterst√ºtzung f√ºr regul√§re Ausdr√ºcke bereitgestellt, mit den `Pattern` und `Matcher` APIs und Methoden in `String` wie `split`, `replaceAll`, `find`, die √ºber die Jahre weitere Verbesserungen erfuhren.

Mit Java 20 wurden einige Neuerungen in diesem Bereich ver√∂ffentlicht,
die f√ºr mich den Anlass bildeten, dieses Thema mal wieder aufzugreifen.

=== Regul√§re Ausdr√ºcke

Die Anforderung, Texte nach bestimmten Mustern zu durchsuchen gibt es schon seit den Anf√§ngen der Informationsverarbeitung.

Ein minimaler Ansatz um einen String zu finden, ist es den String als Byte- oder Charakter-Feld Element f√ºr Element zu durchsuchen, bis man das erste Zeichen des Suchstrings gefunden hat, um dann die weiteren Zeichen zu √ºberpr√ºfen.
Das kann man zwar mit SIMD Operationen optimieren, aber es ist schon ziemlich beschr√§nkt.

Auf der anderen Seite sind komplette Volltext-Indizes wie Lucene zu finden, die eine gro√üe Anzahl von Dokumenten tokenisieren, und in speziellen (invertierte oder trigram) Indexstrukturen vorhalten, um dann komplexe, partielle Abfragen √ºber all diese Dokumente vorzunehmen.

Regul√§re Ausdr√ºcke sitzen in der Mitte, man kann leicht auf einzelnen oder wenigen Texten, relativ komplexe Ausdr√ºcke f√ºr Textmuster finden, und die heutigen Implementierungen daf√ºr sidn auch ziemlich optimiert.

Eine fr√ºhe und sehr leistungsf√§hige Implementierung war in Perl zu finden.
PCRE (Perl Compatible Regexp Engine) bildet auch heute noch in vielen Programmiersprachen das Backend der API.
In Java ist das anders, hier wurde die Implementierung neu erstellt (TODO), daher verhalten sich regul√§re Ausdr√ºcke in Java anders als in anderen Programmiersprachen.

=== Regul√§re Ausdr√ºcke in Java

Wie so oft, nutzen wir wieder `jshell` um unsere Experimente auszuf√ºhren und `sdkman` um das JDK zu installieren (Listing 1).

.Listing 1 - Installation von Java 20
[soure,shell]
----
sdk install java 20-open
jshell
----

Java hat 2 Besonderheiten, die den Umgang mit regul√§ren Ausdr√ºcken schwieriger gestalten als es sein m√ºsste.

Eine Besonderheit in Java Strings ist, dass literale Backslashes noch einmal escaped werden m√ºssen, und da regul√§re Ausdr√ºcke voll davon sind, gibt das eine Backslash Party.

Weiterhin m√ºssen in Java regul√§re Ausdr√ºcke immer den ganze String √ºberdecken, damit wird ein Ausdruck f√ºr nur einen Teilstring nicht als korrekte √úbereinstimmung gewertet.

Die einfachsten Nutzungen sind `String.matches(regexp)` und `String.replaceAll(regexp, text)`, sowie `String.split(regexp)`.

Hier ein paar erste Beispiele in Listing 2, 3 und 4.

.Listing 2 Beispiele mit String.matches
[source,java]
----
"JavaSpektrum".matches("Java")
// false, da nicht der ganze String abgedeckt wurde
"JavaSpektrum".matches("Java.+")
// true, jetzt haben wir den ganze String erfasst
"JavaSpektrum".matches("Java\\w+")
// true, der zweite Teil sind alles Wortbestandteile
"JavaSpektrum".matches("[Ja-v]{4}\\w+")
// wir k√∂nnen auf Zeichen aus einem Set limitieren, und angeben wieviele es sind
"JavaSpektrum".matches("[^.Net]{4}\\w+")
// oder auch das set negieren
"[Hun19]".matches("\\[[A-Z]\\w+\\d*\\]")
// true
"[Hun19]".matches("\\[[A-Z]\\w{2,3}\\d{2}\\]")
// true, das ganze ist jetzt viel enger gefasst, mit 3-4 Zeichen und 2 Zahlen
----

.Listing 3 Beispiele mit String.replaceAll
[source,java]
----
"Hello World".replaceAll("[aeiou]","*")
// "H*ll* W*rld"

"Hello World".replaceAll("\\b","~")
// "~Hello~ ~World~" Wortgrenzen ersetzen
----

`String.replaceAll` ist circa √§quivalent zu `Pattern.compile(regexp).matcher(string).replaceAll(replacement)`, hat aber ein paar Abk√ºrzungen f√ºr kurze Strings, die keine regul√§ren Ausdr√ºcke sind, da die Kompilation des Patterns dann zu teuer w√§re.

.Listing 4 Beispiele mit String.split
[source,java]
----
"1-2-3".split("-")
// String[3] { "1", "2", "3" }

"A-++-,,-B-,-C".split("[+,-]+")
// String[3] { "A", "B", "C" } - Wiederholungen und mehrere Trennzeichen

"Hi Du Java".split("\\b")
// String[5] { "Hi", " ", "Du", " ", "Java" } - Split an Wortgrenzen

"Hi Du".split("")
// String[5] { "H", "i", " ", "D", "u" }
// Netter Trick um einen String in Einzelzeichen zu zerlegen
----

`String.split`` ist sehr n√ºtzlich um Texte an Trennzeichen aufzusplitten, kann aber nicht zwischen Trennzeichen und Textinhalt unterscheiden.
Auch hier gibt es in der Implementierung wieder eine Abk√ºrzung f√ºr die Nutzung von Einzelzeichen, die keine regul√§ren Muster sind.


=== Regul√§re Ausdr√ºcke

Komplexe regul√§re Ausdr√ºcke zu schreiben, zu lesen und ggf. nach 4 Wochen wieder zu verstehen, ist schon eine Kunst und bedarf einiger √úbung.

Ein Monster-Beispiel f√ºr einen abschreckenden regul√§ren Ausdruck, den niemand warten m√∂chte ist die "korrekte" Pr√ºfung einer Email Adresse nach RFC 5322 (Listing 5), es gibt davon aber auch mehrseitige Varianten.

.Listing 5 Email Regexp
----
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
----

Tabelle 1 stellt nur die minimalen Muster, dar die in allen Implementierungen von regul√§ren Ausdr√ºcken funktionieren.

.Tabelle 1 - Wichtige Bestandteile von Regul√§ren Ausdr√ºcken
[opts=header,cols="1m,5a"]
|===
| Muster | Bedeutung
| . | Ein beliebiges Zeichen
| * | beliebig viele Vorkommen
| + | mindestens ein Vorkommen
| ? | optionales Vorkommen
| {3} | n-Vorkommen
| {2,5} | n bis m Vorkommen
| +? | minimale Vorkommen, nach einem Qualifikator
| +? | maximale Vorkommen, nach einem Qualifikator
| [a-z] | ein Zeichen aus Bereich
| [^abc] | kein Zeichen aus Set
| [a-z&&[def]] | Schnittmenge aus beiden Sets
| (a\|b) | Alternative
| \\w | Wortbestandteil (`\W` Negation)
| \\s | Whitespace (`\S` Negation)
| \\d | Ziffer (`\D` Negation)
| \\b | Wortbegrenzung (`\B` Negation)
| ^ | Anfang der Zeile
| $ | Zeilenende
| (abc) | Gruppe
| $1 | Ersetzung f√ºr n-te Gruppe
| xxx | benannte Gruppe
| $1 | Ersetzung f√ºr benannte Gruppe
| (?i) | Optionen (siehe unten)
|===

In [JavaPattern] gibt es die komplette Aufstellung, zus√§tzlich sind vor allem noch die Charakter-Klassen zu nennen, einige davon sind in Tabelle 2 zu finden.

Die POSIX Klassen haben die Struktur `\p{Klasse}` und deren Negation mit `\P{Klasse}`.

.Tabelle 2 - Ausgew√§hlte spezielle Klassen
[opts=header,cols="1m,5a"]
|===
| Muster | Bedeutung
| \p{Lower} | Kleinbuchstaben (ASCII) 
| \p{Alpha} | Buchstaben
| \p{Alnum} | Alphanumerisch
| \p{Punct} | Interpunktion
| \p{InGreek} | Griechische Zeichen
|===

=== Referenzen auf Gruppen

Eine der wichtigsten Eigenschaften von Regul√§ren Ausdr√ºcken ist es ein Teilmuster als Gruppe zu markieren und sich sp√§ter auf diese zu beziehen.
Das ist sowohl bei Wiederholungen im Usprungsmuster n√ºtzlich, als auch bei Ersetzungen.

Diese Gruppen werden in Klammern eingefasst `(Muster)`, es ist oft √§rgerlich dass auch Alternativen in Klammern `(A|B)` gefasst sind und damit automatisch als Gruppen z√§hlen, es sei denn man schliesst sie aus, mittels `(?:A|B)` als "non-capturing group".

Die Referenz darauf ist `\N` wo bei sich das auf die `N-te` Gruppe bezieht.

Leider haben beide eine unterschiedliche Syntax, R√ºckw√§rtsreferenzen in Ersetzungen werden mit `$N` bezeichnet, nicht mit `\N`.

.Listing 6 - Referenzen auf Gruppen
[source,java]
----
"DODO".matches("(..)\\1")
// Bezug auf den ersten Teilstring
"DODODO".matches("(..)\\1+")
// Das kann auch beliebig oft wiederholt werden
"DODODOODODOD".matches("(.)(.)(\\1\\2|\\2\\1)+")
// Auch in Einzelbez√ºgen

"DODODO".replaceAll("(.)(.)","$2$1")
// Pl√§tze tauschen
"DODODO".replaceAll("(.)(.)","$1$2$2$2")
// Vervielfachen
"Hello World".replaceAll("(He)(ll.*?\\b)","$1aven")
// "Heaven World"
// Komplexeres Muster Ersetzen
----

Mit Java 1.7 kamen benannte Gruppen hinzu, die das Hantieren mit den index-basierten Bez√ºgen sehr vereinfachen, besonders wenn der Ausdruck modifiziert wird und sich damit die Positionen √§ndern.
Dasselbe Problem hat man bei SQL-`ResultSet` Ergebnissen und Feldzugriffen, wenn m√∂glich empfehlen ich dann immer auf die Spaltennamen zuzugreifen bzw. die Felder mittels Konstanten oder Enums zu benutzen.

In Java 20 wurde der Zugriff auf benannte Gruppen innerhalb der Java API noch einmal verbessert.

Die Syntax f√ºr benannte Gruppen ist `(?<name>...)` und die Referenzen sind `\k<name>` bzw. `${name}`.

In Listing 7 ist unser Beispiel noch einmal mit benannten Gruppen zu sehen.

.Listing 7 - Referenzen auf benannte Gruppen
[source,java]
----
"DODO".matches("(?<do>..)\\k<do>")
// Bezug auf den ersten Teilstring
"DODODO".matches("(?<do>..)\\k<do>+")
// Das kann auch beliebig oft wiederholt werden
"DODODOODODOD".matches("(?<d>.)(?<o>.)(\\k<d>\\k<o>|\\k<o>\\k<d>)+")
// Auch in Einzelbez√ºgen

"DODODO".replaceAll("(?<d>.)(?<o>.)","${o}${d}")
// Pl√§tze tauschen
"DODODO".replaceAll("(?<d>.)(?<o>.)","${d}${o}${o}${o}")
// Vervielfachen
"Hello World".replaceAll("(?<he>He)(?<ll>ll.*?\\b)","${he}aven")
// "Heaven World"
// Komplexeres Muster Ersetzen
----

////
=== Lookahead / Lookbehind

(?=X)	X, via zero-width positive lookahead
(?!X)	X, via zero-width negative lookahead
(?<=X)	X, via zero-width positive lookbehind
(?<!X)	X, via zero-width negative lookbehind
(?>X)	X, as an independent, non-capturing group
////

=== Matcher Pattern

Die Nutzung von regul√§ren Ausdr√ºcken in den String-Funktionen funktioniert zwar, ist aber nicht besonders effizient, da der Ausdruck bei jedem Aufruf wieder neu f√ºr die Verarbeitung √ºbersetzt werden muss.

Mit dem `Pattern.compile(regexp[, optionen])` Aufruf kann dies einmalig geschehen und als Konstante festgehalten werden.

.Listing 8 - Pattern API
[source,java]
----
Pattern p = Pattern.compile("(a*)b");
Matcher m = p.matcher("aaaaab");
boolean b = m.matches();
int start = m.start();
int end = m.end();
String group = m.group();
// true, 0, 6, aaaaab

int start = m.start(1);
int end = m.end(1);
String group = m.group(1);
// true, 0, 5, aaaaa

// √§quivalent, macht das Muster nicht verf√ºgbar
boolean b = Pattern.matches("(a*)b", "aaaaab");
----

Mit der so gewonnenen `Pattern` Instanz, kann dann Funktionalit√§t wie `split`, `splitAsStream`, `as(Match)Predicate` direkt genutzt werden.

Seit Java 20 gibt es auch `namedGroups()` Methode, die eine `Map` von Gruppenname zu ihrem Index erzeugt.

Die Hauptnutzung in der API ist aber die Erzeugung eines sogenannten `Matcher` f√ºr eine `CharSequence`, der die Iteration und Verarbeitung der einzelnen Treffer √ºbernimmt.

Dieser kann √ºber die `matches()` Methode, feststellen ob die ganze `CharSequence` dem Muster entspricht, siehe Listing 8.
Wenn das der Fall ist, kann die Position als `MatchResult` mit `start()` und `end()` und der aktuelle Treffer mittels `group()` ermittelt werden.
Diese Methoden haben auch jeweils eine Variante mit Gruppennummer bzw -namen f√ºr Gruppen innerhalb des aktuellen Musters.

Viel n√ºtzlicher ist aber die inkrementelle Verarbeitung.

Dann muss auch nicht mehr der ganze String zum Muster passen, da das Muster immer wieder ab der aktuellen Position gesucht wird, wie in Listing 9 gezeigt.

.Listing 9 - Matcher API
[source,java]
----
// \\w+?a -> minimaler Wortbestandteil gefolgt von "a"
Pattern p = Pattern.compile("(?<davor>\\w+?)(a)");
p.namedGroups();
// {davor=1}
var text = "JavaSpektrum herausgegeben von Sigs Datacom";
Matcher m = p.matcher(text);

while (m.find()) {
   System.out.printf("Treffer %d-%d - %s%n", 
        m.start(),m.end(),m.group());
   System.out.printf("Davor %d-%d - %s%n", 
        m.start("davor"),m.end("davor"),m.group("davor"));
   System.out.printf("Gruppe %d-%d - %s%n", 
        m.start(2),m.end(2),m.group(2));
}
/*
Treffer 0-2 - Ja
Davor 0-1 - J
Gruppe 1-2 - a
Treffer 2-4 - va
Davor 2-3 - v
Gruppe 3-4 - a
Treffer 13-17 - hera
Davor 13-16 - her
Gruppe 16-17 - a
Treffer 36-38 - Da
Davor 36-37 - D
Gruppe 37-38 - a
Treffer 38-40 - ta
Davor 38-39 - t
Gruppe 39-40 - a
*/
----

=== Optionen

Es gibt einige Optionen (Tabelle 3) die, entweder √ºber die Pattern API als Konstanten oder inline mittels `(?mid-sux)` angeben kann, ihre Deaktivierung erfolgt durch vorangestelltes Minuszeichen.

.Tabelle 3 - Regexp Optionen
[opts=header, cols="m,m,a"]
|===
| Buchstabe | Konstante | Bedeutung
| i | CASE_INSENSITIVE | Ignoriert Gro√ü-/Kleinschreibung f√ºr ASCII
| m | MULTILINE | `^` und `$` matchen auch Zeilenumbr√ºche
|   | LITERAL | Alle 
| d | UNIX_LINES | Nur `\n` als Zeilenumbruch
| s | DOTALL | `.` steht auch f√ºr Zeilenumbr√ºche, Muster gilt √ºber Zeilengrenzen hinweg
| x | COMMENTS | Kommentare mittels `#` bis zum Zeilen ende, Whitespace muss escaped werden
| u | UNICODE_CASE | Kleinschreibung auch f√ºr Unicode
| U | UNICODE_CHARACTER_CLASS | Unicode Versionen der Klassen werden unterst√ºtzt
|===

=== Suchen & Ersetzen

Die bisherige Nutzung von `replaceFirst` oder `replaceAll` zeigte nur konstante Ersetzungen bzw. die Nutzung von Gruppen.

Die Methode `replaceAll` kann aber auch mit einem Lambda-Ausdruck benutzt werden, der dann f√ºr jeden Treffer ausgef√ºhrt wird und dynamisch entscheiden kann, was zu tun ist, bzw. womit ersetzt werden soll.

In Listing 10 gibt es ein Beispiel in dem Zahlen durch ihre Zahlworte aus einer Liste ersetzt werden. 
Die `match` Variable in der Lambda Closure ist ein `MatchResult`, das auch √ºber die schon genutzten Methoden `start`, `end`, `group` in ihren Varianten verf√ºgt.

.Listing 10 - replaceAll Lambda
[source,java]
----
String[] zahlen = {"null", "eins", "zwei", "drei", "vier", 
        "f√ºnf", "sechs", "sieben", "acht", "neun"};

String text = "4 7 1 1";
Pattern p = Pattern.compile("\\d");
Matcher m = p.matcher(text);

var worte = m.replaceAll((match) -> {
  String zahl = match.group();
  int index = Integer.parseInt(zahl);
  return zahlen[index];
});
// "vier sieben eins eins"
----

Unter der Haube wird in der `Matcher` Klasse f√ºr `replaceAll` immer noch das klassische `appendReplacement(StringBuilder, "replacement")` und `appendTail(StringBuilder)` benutzt, das es schon seit Java 1.4 gibt (damals nur mit `StringBuffer`).
Im Listing 11 ist ein Beispiel zu sehen, in dem L√§nderk√ºrzel durch ihre Flaggen ersetzt werden.

.Listing 11 - Suchen und Ersetzen auf die althergebrachte Variante
[source,java]
----
Pattern p = Pattern.compile("[A-Z]{2}", 
          Pattern.UNICODE_CHARACTER_CLASS);
Matcher m = p.matcher("FR UA UK GR");
StringBuilder sb = new StringBuilder();
while (m.find()) {
    var code = m.group();
    var flag = switch (code) {
        case "FR" -> "üá´üá∑";
        case "GR" -> "üá¨üá∑";
        case "UK" -> "üá¨üáß";
        case "UA" -> "üá∫üá¶";
        default -> code;
    };
    m.appendReplacement(sb, flag);
    System.out.printf("%d-%d (%s) - %s%n",
        m.start(), m.end(), m.group(), sb);
}
m.appendTail(sb);
/*
0-2 (FR) - üá´üá∑
3-5 (UA) - üá´üá∑ üá∫üá¶
6-8 (UK) - üá´üá∑ üá∫üá¶ üá¨üáß
9-11 (GR) - üá´üá∑ üá∫üá¶ üá¨üáß üá¨üá∑
*/
----

////
=== Scanner

Um regul√§re Ausdr√ºcke auf gr√∂√üere Texte anzuwenden, kann `java.util.Scanner` genutzt werden.
Diese Klasse bietet APIs um strukturierte Texte zu parsen, man kann Trennzeichen (als regul√§re Ausdr√ºcke) setzen, sowie f√ºr jeden Treffer bestimmen, was im aktuellen Fall geschehen soll.

In Listing 15 ist ein Beispiel zu sehen.

.Listing 15 Scanner
[source,java]
----
import java.util.Scanner;

var text = """
  <Li>Pattern</li>
  <LI>Matcher</lI>
  <li>MatchResult</LI>
""";
var LI_START = Pattern.compile("(?i)\\s*<li>");
var LI_END = Pattern.compile("(?i)</li>\\s*");
try (Scanner scanner = new Scanner(text)) {
    scanner.useDelimiter(LI_START);
    while (scanner.hasNext()) {
        String listItem = scanner.next();
        if (!listItem.isBlank()) {
            System.out.printf("* %s", listItem.trim());
        }
        scanner.useDelimiter(LI_END);
        if (scanner.hasNext()) {
            System.out.println();
            scanner.next();
        }
        scanner.useDelimiter(LI_START);
    }
}
----
////

=== Performance

Regul√§re Ausdr√ºcke anzuwenden ist eine komplexe Operation die oft in einer Zustandsmaschine realisiert wird.
Besonders f√ºr komplexe Ausdr√ºcke mit exponentiellem Backtracking und sich ausschliessenden, selbst-referenzierten (Teil-)mustern ist der Aufwand zur Aufl√∂sung hoch.
Dort lohnt es sich das Muster zu vereinfachen und dann ggf. in einem zweiten Schritt die Feinaufl√∂sung durchzuf√ºhren, um inkorrekte Zwischenergebnisse auszufiltern.

Besonders wenn Nutzereingaben als regul√§re Ausdr√ºcke ausgef√ºhrt werden, sollte es vermieden werden, eine Implementierung mit quadratischer Komplexit√§t zu nutzen.
Das kann zu Problemen f√ºhren entweder indem entweder der Stack nicht ausreicht oder die Berechnung so aufw√§ndig wird, dass ein Denial-Of-Service ([ReDOS]) hervorgerufen wird.

√úber die Jahre gab es viele Forschungsbeitr√§ge zur Optimierung und auch geeignete effiziente Bibliotheken, auch in Java ist der [PerformanceJEP] noch offen, der eine Verbesserung der Performanz der Implementierung beitragen soll.

////
There is an increasing focus on the performance of regular expression matching, and especially the predictability.

regular expression denial of service attacks are sufficiently well known in the industry that the term ReDoS has been coined.
it is common for web sites to provide a search service for large text corpora with user-provided regexes, and having a reliably efficient (i.e. O(N)) regex evaluation engine may be considered a strict requirement. This was the impetus for Russ Cox's re2 library,.
it is surprisingly difficult to solve some common software engineering problems efficiently with just a regex. The prime example is detecting and removing trailing whitespace, which is explored in a microbenchmark and was the cause of the famous stackoverflow outage caused by \s+$.. It is not true that careful crafting of regexes to use e.g. possessive quantifiers, by a skilled engineer, can solve a particular regex performance problem.
The use of Matcher#find (instead of Matcher#matches) is very convenient, but introduces an implicit O(N) loop over the input, or alternatively, a non-possessive "^.*?" prefix in the regex. In order for the entire search operation to not be O(N^2), most of the regex match operations while scanning the input need to be O(1), which may require the use of less-obvious constructs like lookbehind. The use of possessive quantifiers in the regex itself is sadly insufficient.
The current (jdk16) implementation is a NFA-based backtracking engine. It mitigates but does not eliminate O(2^N) performance. StackOverflowError is a risk.

Goals
Make it possible to build a ReDoS-safe "regexp search engine" that can safely accept user-provided regexes with O(N) runtime performance, O(1) stack space usage, and as close as possible to O(M) space usage for the compiled regex. It's OK for some regex features like backrefs to be dropped. Users can ask for safety or power; no one knows how to provide both. Of course, we maintain compatibility - the legacy API must remain unsafe.
////
////
=== Bessere Volltext-Indizes

Nat√ºrlich sind regul√§re Ausdr√ºcke nicht daf√ºr optimiert aus einer gro√üen Menge von Dokumenten die relevanten Fundstellen f√º
r Text 
////

=== Regul√§re Ausdr√ºcke testen

Neben JShell oder der IntelliJ Suche, gibt es diverse Online-Tools [Regex101], [Regexr] mit denen man regul√§re Ausdr√ºcke auf verschiedenen Bespielen testen kann.
Das [RegexpCheatSheet] von RebeLabs (RIP) ist auch sehr praktisch.

Es w√§re aber nicht 2023 wenn uns hier ChatGPT nicht weiterhelfen k√∂nnte.
Dort kann man sich sowohl regul√§re Ausdr√ºcke erkl√§ren, als auch Testdaten generieren lassen.

.Erkl√§rung eines regul√§ren Ausdrucks - ChatGPT-4
****
Frage:
Erkl√§re den folgenden regul√§ren Ausdruck und wo er genutzt werden k√∂nnte:
^[\w.]+@[\w.]+?\.(com|net|org|de)$

Antwort:
Dieser regul√§re Ausdruck pr√ºft, ob eine Zeichenfolge eine g√ºltige E-Mail-Adresse enth√§lt.

* `^` bedeutet, dass der regul√§re Ausdruck am Anfang der Zeichenfolge beginnen soll.
`[\w.]+` gibt eine oder mehrere Zeichen von alphanumerischen Zeichen und dem Punkt zur√ºck. Dies gilt f√ºr den Benutzernamen vor dem "@"-Zeichen.
* `@` pr√ºft, ob die Zeichenfolge das "@"-Zeichen enth√§lt.
*`[\w.]+?` gibt eine oder mehrere Zeichen von alphanumerischen Zeichen und dem Punkt zur√ºck. Dies gilt f√ºr den Domainnamen nach dem "@"-Zeichen. Das `?` ist ein nicht-greedy-Operator und stellt sicher, dass nur so viele Zeichen wie m√∂glich erfasst werden.
* `\.` pr√ºft, ob das "."-Zeichen vorhanden ist.
* `(com|net|org|de)` gibt eine von vier m√∂glichen Top-Level-Domains zur√ºck.
* `$` bedeutet, dass der regul√§re Ausdruck am Ende der Zeichenfolge enden soll.

Dieser regul√§re Ausdruck k√∂nnte genutzt werden, um sicherzustellen, dass eine Eingabe von Benutzern tats√§chlich eine g√ºltige E-Mail-Adresse enth√§lt, bevor sie in eine Datenbank oder ein Formular eingetragen wird.

Frage:
Generiere jeweils 3 passende und unpassende E-Mail Adressen f√ºr diesen regul√§ren Ausdruck

Antwort:
Passende E-Mail-Adressen:

* john.doe@example.com
* jane.doe@example.net
* peter.parker@example.de

Unpassende E-Mail-Adressen:

* john.doe@example
* jane.doe@example.
* peter.parker@example.invalid
****

=== Andere Anwendungen

Die h√§ufigste Anwendung von regul√§ren Ausdr√ºcken ausserhalb von Programmiersprachen ist in Editoren und Tools (grep, ag, vi, sed, Google Docs, VS Code).
Aber auch in der Textverarbeitung in Datenbanken oder Big Data Systemen (Spark, Flink) sowie ML-Anwendungen werden sie h√§ufig genutzt, besonders zur Textanalyse.

=== Fazit

Regul√§re Ausdr√ºcke sind ein m√§chtiges Tool und werden in Java gut unterst√ºtzt.
Es ist gut sie im Handwerkszeug zu haben, und zu wissen wann und wo man sie anwenden kann und sollte.
Mit Java 20 wurde ihre Nutzung mit benannten Gruppen noch einmal vereinfacht, ich hoffe dass der JEP zur Leistungsverbesserung bald Eingang in das JDK findet.

=== Referenzen

* [JavaPattern] https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html
* [RegexpCheatSheet] https://www.jrebel.com/blog/java-regular-expressions-cheat-sheet
* [Geschichte] https://en.wikipedia.org/wiki/Regular_expression#History
* [JakartaRegexp] https://jakarta.apache.org/regexp/changes.html
* [Regex101] https://regex101.com/
* [Regexr] https://regexr.com/
* [PerformanceJEP] https://openjdk.org/jeps/8260688
* [Java20Enhancement] https://bugs.openjdk.org/browse/JDK-6350801
* [RegexpWebsite] https://www.regular-expressions.info/
* [Baeldung] https://www.baeldung.com/regular-expressions-java
* [Jenkov] https://jenkov.com/tutorials/java-regex/index.html
* [ReDOS] https://en.wikipedia.org/wiki/ReDoS