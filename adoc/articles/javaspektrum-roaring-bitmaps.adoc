== Roaring Bitmaps - Effiziente Bitmanipulation und -speicherung in Java

Auch wenn wir heutezutage oft nicht mehr mit individuellen Bits zu tun haben, lauern sie doch direkt unter der Oberfläche unserer Programme.
Zum Beispiel sind die seltsamen Ergebnisse bei Gleitkommazahlen damit zu erklären, wie sie als Exponent und Mantisse in den 16, 32 (float) oder 64 bit (double) abgelegt werden und welche Zahlen damit ausdrückbar sind.

Leider ist es in Java nicht einfach möglich Booleans statt Bits zu benutzen, da für das Speichern eines booleschen Wertes noch immer ein ganzes Byte benutzt wird, bis Java X war es sogar ein Integer mit 4 Bytes.
Wie Booleans zu repräsentieren sind, ist in der Spezifikation der VM nicht vorgegeben, verschiedene JVM Anbieter könnten das unterschiedlich handhaben.
Damit wird mindestens 8x so viel Speicher verbraucht wie für einen Wahrheitswert benötigt würde, ein Grund mehr sich mit Bits und Bitsets zu beschäftigen.

Zum Beispiel in Datenbanksystemen wie Neo4j in denen es auf jedes Bit (Byte) ankommt, können komplexere Datenstrukturen mit Bestandteilen, die keine vollen Bytes füllen, in kompakteren Strukturen mittels Bitpacking (TODO andere Bedeutung) gespeichert werden.

In HunXxx hatte ich auch schon einmal über die effiziente Repräsentation von Daten berichtet.

=== Kleiner Ausflug in die Welt der Bits

Auch wenn Sie sich alle sicher noch daran erinnern, wie Bit-Operationen funktionieren, hier noch einmal eine kleine Wiederholung.

Zahlen in den meisten Digitalsystemen werden nicht im Dezimal, sondern im Binärsystem dargestellt, wobei an jeder Stelle (2^0, 2^1, 2^2 usw.) eine 0 oder 1 dieses Bit aktiviert oder nicht. 
Damit können in einem Byte 256 Zahlen dargestellt werden, von 0 bis 255 oder mit dem ersten Bit als Vorzeichen (-128 bis 127) (Java Short).
Oft werden Bytes als zwei 4-Bit Hälften (Nibbles) dargestellt, die jeweils 16 Zahlen (0..15) umfassen, im Hexadezimalsystem (0..F).

In Java können Binärzahlen mit einem Suffix (b) direkt dargestellt werden, das ist nützlich wenn man diese für einen Algorithmus oder eine bestimmte Struktur direkt darstellen möchte.
Hexadezimalzahlen beginnen mit einem `0x` Präfix, z.b. `0x2A` für Dezimal `42`.
Das ganze wird oft auch für Ascii-Tabellen genutzt die nur 7 oder 8 Bit benötigen, für Unicode sind es dann 2 bis 4 Bytes.

Bit-Operationen verändern einzelne Bits in einer Binärzahl und sind in Prozessoren direkt in Hardware abgebildet.


Die typischen Operationen sind in Tabelle 1 aufgeführt.

[%autowidth,opts=header, cols="a,m,m,a"]
|===
| Name | Symbol | Beispiel | Erklärung
| Negation | ~ | ~0b1001 = 0b0110 | Jedes Bit wird invertiert
| Und  | & | 0b1001 & 0b1010 = 0b1000 | Wenn Bit an Position in beiden Werten 1 dann bleibt es 1 sonst 0
| Oder | \| | 0b1001 \| 0b1010 = 0b1011 | Wenn Bit an Position in beiden Werten 0 dann bleibt es 0 sonst 1
| Rechts schieben | >> | 0b1001 >> 1 = 0b0100 | Alle Bits werden um N Stellen nach rechts verschoben
| Rechts schieben mit Vorzeichen | >>> | 0b1001 >> 1 = 0b1100 | Alle Bits werden um N Stellen nach rechts verschoben, dabei wird das höchstwertige Bit wieder eingefügt
| Links schieben | << | 0b1001 << 1 = 0b0010 | Alle Bits werden um N Stellen nach links verschoben, führende Bits können verloren gehen
|===

Es gibt auch weitere Operationen, wie zum Beispiel das Zählen von Bits in einer Zahl, die erste oder letzte Position eines aktiven Bits.

Vor der Einführung von Enums waren Bit-Konstanten in Java immer noch üblich, um zum Beispiel Konfigurationsoptionen abzubilden.

Das ist auch immer noch in Klassen wie A, B und in Datei- bzw. Netzwerkoperationen, die mit dem Betriebsysstemkern interagieren notwendig.

Für diese Flags werden oft separate Zweierpotenzen für die Werte benutzt, so dass sie miteinander mittels oder `Flags| FLAG` aktiviert, oder mittels nicht-und `Flags & ~FLAG` deaktiviert werden können.
Ein Beispiel ist in Listing 2 zu sehen.

[source,java    ]
----
final static int FLAG_1 = 0b0001;
final static int FLAG_2 = 0b0010;

// Flag 1 und 2 setzen
int option = FLAG_1 | FLAG_2;

if (option & FLAG_1 != 0) {
    // flag 1 gesetzt
}
// Flag 2 löschen
option = option & ~FLAG2;

if (option & FLAG_2 != 0) {
    // flag 2 gesetzt
}
----

Im Allgemeinen können bestimmte, komplexere Bitmuster, auch Masken  genannt, genutzt werden um schnell zu testen, welche Bits gesetzt sind. 
Dazu wird der Wert mit der Maske mittels UND `&` verknüpft, so dass, falls alle relevanten Stellen eine 1 haben, ein Wert größer 0 übrig bleibt.

Für das Setzen der Maske wird sie mittels Oder `|` mit dem existierenden Wert und für das Löschen mit der negierten Make mit Und `&` veknüpft.

Maskenbeispiele

Da für jedes Flag ein unabhängiges Bit genutzt werden muss, können in einem Byte 8, in einem Integer-Wert 32 und in einem Long 64 Flags (Bits) gepeichert werden.

Statt Flags könnten diese Positionen auch boolesche Informationen über Dokumente, Datenbankspalten oder -zeilen, Nachbarknoten in einem Graph oder andere Fakten reprästentieren.

Das wird im allgemeinen mit einem BitSet erreicht, dh. einer größeren Anzahl von Bits die effizient gelesen, geschrieben und verwaltet werden können.


=== Wozu sind Bitmaps nützlich?

Wenn es nur darum geht, einen Fakt über eine fortlaufende Zahl, wie eine Id eines Eintrags zu speichern, dann reicht ein Bit in einer fortlaufenden Reihe aus.
Somit könnten in einem Long Wert 64 solche Fakten gespeichert werden.
Falls mehr Einträge nötig sind, müsste man mehrere Long-Werte kombinieren, z.b. 10 für 640 Bits.

image::https://vikramoberoi.com/content/images/2022/08/bitmap-3.png[]

Für das Management der notwendigen Long-Werte, insbesondere wenn vorher nicht bekannt ist, wieviele benötigt werden und weitere Operationen ist es sinnvoll diese in einer Klasse zu kapseln.

Die API eines Bitsets hat aber meist keine Bit-Muster als Parameter sondern, die fortlaufenden Integer/Long Werte, die im Bitset aktiv (enthalten) oder inaktiv (nicht enthalten) sind und deren Set-Operationen.

Diese Art von Bitset wird oft als Bitmap Index oder Bit-Index bezeichnet und benutzt.

Diese einfache `BitSet` Klasse ist im JDK seit Java xx vorhanden und funktioniert ausreichend gut für kleinere Bitsets also ein paar Tausend bis Zehntausend Bits.
In Listing {counter:listing} ist ein einfaches Anwendngsbeispiel zu sehen.


.Listing {listing} - Java BitSet API Beispiel
[source,java]
----

----

[BaeldungBitset]

Für größere Anzahl von Bits wird der Speicherbedarf relevant, für eine Million Bits werden schon 122 Kilobytes benötigt. Für eine Milliarde Bits 119 Megabytes.

Warum würde man trotzdem BitSets benutzen? 

Effiziente Implementierungen von Schnitt- und Vereiningungsmengen von Bits haben viele Anwendungsfälle

* Suchmaschien TF/IDF (Term Frequency / Inverse Document Frequency) - Tritt ein Term in einem Dokument auf? und die Verküpfung von Termen -> Bitmasken Verknüpfung -> Beispiel
* Datenbankabfragen
* Boolesche Werte (Existenz)
* Spalten-Datenbanken Optimierungen (Columnar Database)
* 

TODO Beispiel Term - Dokument - Und Verknüpfung

Glücklicherweise erfolgt die Nutzung von Bitsets nicht in einem stochastischen Raum, in dem es zufällig ist, ob ein Bit gesetzt ist oder nicht. 
Dann gäbe es wenige Optimierungsmöglichkeiten.

In der Realität sind eine ganze Menge von Beobachtungen zu machen:

* Große Bereiche haben keine Informationen, sind also ungenutzt, Bitsets sind oft *spärlich* besetzt (sparse bitset)
* Es gibt wiederkehrende Muster von Informationen, oft sind längere Bereiche durchweg gesetzt oder gelöscht
* Oft sind bestimmte Muster von Aktivierungen zu beobachten, in einem Histogram gibt es Häufungen z.B. 0xb10011001 könnte viel häufiger vorkommen als andere Muster
* Bestimmte Bereiche des Bitsets werden aktiv bearbeitet, andere dagegen sind nicht im Fokus
* Ggf wird das BitSet oder Bereiche davon nur gelesen und nie geschrieben
* Ganze Bereiche des Bitsets sind ähnlich und könnten wieder genutzt werden
* Bestimmte Operationen des Bitsets können mit gecachten Informationen 

Sparse Beispiel - einige wenige "große" Zahlen sind indiziert.

-> z.b. Eintrag mit 10M gesetzt/hinzugefügt.

All diese Aspekte zeigen, auf, wie BitSets optimiert werden können:

* nicht genutzte Bereiche können einfach markiert werden, ohne eigenlichte 
* Kompression wiederkehrender Muster, am einfachsten mit einer Lauflängenkomprimierung, komplexer mit einem 
* Baumrepräsentation, in dem ganze Teilbäume weggelassen oder virtuell repliziert werden können


Natürlich muss die Optimierung eine gute 

=== Roaring Bitmaps

Hier kommen Roaring Bitmaps ins Spiel.
Ich habe zuerst von der Bibliothek vor ca 10 Jahren von einem Kollegen gehört, der in seinen Experimenten an die Grenzen von selbsterstellten Lösungen und des Java Bitsets kam.
Mit Millisekunden Anforderungen für komplexe Graph Abfragen und -Algorithmen, in denen Bitsets genutzt wurden, um zu vermerken, ob ein bestimmter Knoten schon einmal besucht worden war, musste jede Möglichkeit der Optimierung in Betracht gezogen werden.

Roaring Bitmaps erwiesen sich da als hilfreiches Werkzeug.

[quote]
Use Roaring for bitmap compression whenever possible. Do not use other bitmap compression methods 
-- (Wang et al., SIGMOD 2017)


Hintergrund:

Die Idee für Roaring Bitmaps kam aus der Forschung - Daniel Lemire, Owen Kaser und Gregory Ssi-Yan-Kai haben in einem Paper [RBMPaper] in 2016 eine Implementierung für komprimierte Bitsets vorgestellt, die von Roaring Bitmaps implementiert wurde.

Komprimierung ohne Einbuße in Performance - Wie?

Bei vorheriger Forschung gabs es zwar hohe Kompressionsraten diese gingen aber mit signifikanter Leistungseinbuße einher.

Die API von Roaring Bitmaps ist ähnlich der Bitset API, wie in {counter:listing} zu sehen.

.Listing {listing} - Roaring Bitmap API Beispiel
[source,java]
----

----

In Roaring Bitmaps wurden eine Reihe von Mechanismen kombiniert, die in Summe die beobachtbaren Verbesserungen erreichen.

Die Roaring BitMap API benutzt 32-Bit Integer Werte, d.h. Einträge sind auf 4 Milliarden begrenzt, bei Bedarf nach mehr Volumen kann z.B. in einem Feld mit Roaring BitMap Objekten mit Präfixen z.B. 16 Einträge (von `0b0000` bis `0b1111`) für 16 x 4Mrd Zahlen.
Es gibt auch 64-Bit Implementierungen von RBM, aber diese sind noch nicht so sehr verbreitet.

Welche Mechanisment gibt es?

==== Chunking

Intern werden Blöcke (Chunks) von 2^16 (65536) Integer Werten zusammengefasst, und jeweils unter ihrem 16 Bit Präfix (höchstwertigen Bits als `N / 2^16` oder `N >> 16`) gruppiert.

Jeder dieser 2^16 möglichen Blöcke ist ein "Container", die eine "Kardinalität" entsprechend ihrer Besetzung (Füllgrad) haben.
D.h. wenn ich 100 Zahlen kleiner als 65536 einfüge kommen diese in den ersten Container und er hat eine Kardinalität von 100.

Für verschiedene Grade von Kardinalitäten gibt es verschiedene Container

* Für spärlich besetzte Container (<= 4096 Einträge, 6,25% Füllgrad) - sortiertes dynamisch wachsendes Feld mit den unteren 16 Bit Werten (`N % 2^16`` oder `N & 0xFFFF``) unserer Zahlen (TODO ausformulieren)
* Dichter besetzte Container (>4096 Einträge) - traditionelles BitMap mit 2^16 Bits also 8 Kilobytes, die komplett alloziert werden. Dabei werden Long-Werte? für die Speicherung der Bits genutzt, also 1024 Long werte. TODO

Für die Verwaltung der Container wird ein sortierter Index benutzt der mittels der 16 höherwertigen Bits auf die Container zeigt und welcher dynamisch wächst, man könnte sich das als primitive IntegerToObject-Map vorstellen.
// Ich denke man könnte aber auch ein dynamisch wachsendes Feld nutzen, das maximal 2^16 Einträge mit jeweils einem Pointer enthält.

==== Einfügen/Löschen von Werten

Einfügen von Werten ist abhängig vom Container Typ.
Zuerst wird überprüft ob im Index schon ein Eintrag für den 16-Bit Präfix vorhanden ist. 
Wenn nein, wird ein neuer Sparse-Container mit diesem Präfix eingefügt.

Im Sparse Container wird die notwendige Position im sortierten Feld mittels Binärsuche gesucht, wenn da noch kein Eintrag vorhanden ist, wird er gesetzt.

Im Bitmap Container wird das Bit für die 

Wenn der Füllgrad also Größe des Containers 4096 übersteigt wird der Sparse-Container durch einen BitMap Container ersetzt.
// Wäre sinnvoll das über Hysterese zu machen, damit es an der Grenze keine Fluktuationen gibt

Ähnlich, nur umgekehrt erfolgt die Löschung eines Bits, nur dass für fehlende Container nichts getan werden muss.
Und dass leere Sparse-Container entfernt werden können, diese könnten in einem Objekt-Pool wiederverwendet werden.

// todo wäre es nicht einfacher, ein statisches Array mit den 65k Bitmaps zu haben und zwischen Indexena auf diese umzuschalten?

==== Test auf gesetztes Bit

Check auf gesetzes Bit / Wert vorhanden

1. Wenn 16-bit Präfix nicht im Index dann Wert nicht gesetzt
2. Sonst Container für Position ermitteln, und untere 16 Bit Wert für Suche nutzen
3. Binärsuche im Feld, falls Sparse Container
4. Bit-test an Position im Bitmap-Container


==== Schnittmengen ermitteln

Nur für Container die in beiden RBM vorhadnen sind müssen Schnittmengen ermittelt werden.

Dabei werden 3 der 4 Kombinationen unterschieden.

* Sparse - Sparse: 
* Sparse - Sparse: Ergebnis ist immer Sparse Container.
Abhängig von den Kardinalitäten:
- Einträge des kleineren Arrays werden im größeren binär gesucht
-  Zwei Pointer werden in beiden Arrays vorwärtsbewegt, solange der Wert in einem der Felder kleiner ist als im anderen. Bei gleichen Wert wird dieser zur Schnittmenge hinzugefügt. (Galloping Intersection)

Sparse - Dense:

Einträge aus dem Sparse Cointainer werden im Dense Container getested, Ergebnis ist immer ein Sparse Container, weil es ja maximal 4096 überlappende Einträge geben kann.

Dense - Dense

Abhängig von Kardinalität können die Bitset Einträge der Container (Long-Werte) miteinander mittels UND verknüpft und das Ergebnis ist je nach Kardinalität ein Dense Container bzw. Sparse Container.

Vereinigungsmenge:

Wenn es nur einen Container mit dem Präfix gibt, ist dieser der neue Container

* Sparse/Sparse - Summe aus beiden Kardinalitäten, wenn < 4096 dann bleibt es ein Sparse Container und die Inhalte werden  mittels Merge Sort zusammegeführt, ansonsten Dense Container und die Bits des Sparse Containers werden einfach gesetzt.
* Sparse/Dense - Bits des Sparse Containers werden gesetzt
* Dense/Dense - Container Inhalte werden per ODER `|` miteinander verknüpft


==== Lauflängenkodierung

Im zweiten Roaring Bitmap Paper [RBMPaperOptimierung] wurde eine weitere Optimierung aktiviert, die Lauflängenkodierung.
Das war auch eine der ersten Kodierungen für Bildformate, für größere Farbflächen (pro Kanal) wurde nur die Farbwert und Anzahl der Pixel gespeichert.

Genauso wird hier in einem Lauflängen-Container (Run Container), die Startposition und Anzahl der gesetzten Bits gespeichert, mit jeweils 2 16-Bit-Werten.

Diese Container können mittels einer Analyse mit der API Funktion `runOptimize` erzeugt werden, oder wenn ein großer Bereich von Bits auf einmal gesetzt wird.
Die Erzeugung eines Run-Containers erfolgt aber nur wenn seine Größe kleiner ist als der existierende Sparse oder Dense-Container, das mit einer Heuristik ermittelbar ist - 4 Bytes pro "Run".

// TODO was ist eine sinnvolle Mindestlänge von Runs?

////
If you'd like to work out computing the heuristic yourself, it'll help to recall the following:

... array containers contain no more than 4,096 integers, packed into 16-bits each.
... bitmap containers contain > 4,096 integers in a bitmap with 2^16 bits (8,192 bytes).
... each run in a run container takes up 32 bits (16 bits for the start, 16 bits for the length).
////

Mit der Einführung dieses neuen Containers mussten die Algorithmen für Schnitt- und Vereinigungsmengen angepasst werden, sowie das Setzen und Entfernen von Bits anpassen.



// Man hätte den Run-Container auch mit dem Array-container kombinieren können, in dem man mit dem höchstwertigen Bit indiziert, ob es ein Run oder regulärer Eintrag ist, und dann der nächste Eintrag die Lauflänge darstellt.

Masken & Tests

Roaring bitmaps are compressed bitmaps which tend to outperform conventional compressed bitmaps such as WAH, EWAH or Concise. In some instances, they can be hundreds of times faster and they often offer significantly better compression.


Eine 

Max De Marzi

Unterstützung für Bitmaps in der Klasse java.util.BitSet in Java seit JDK xxx

https://roaringbitmap.org/

In ein Log 

TODO bitmap index for one-hot encodings 

> Using Roaring bitmaps instead of traditional bitmaps in that application reduced memory usage from ~125GB to 300MB, an impressive 99.8% savings.

=== Performance Vergleich mit JMH

Wie schon so oft, hilft uns JMH die Leistungsfähigkeit der 2 Implementierungen zu vergleichen

TODO welche gibt es noch

In Listing {counter:listing} ist eine der Benchmark Methoden zu sehen.

.Listing {listing} - JMH Performance Test
[source,java]
----
TODO
----


=== Fazit

Ehrlich gesagt, hatte ich mich schon auf den Roaring-Bitmap-Artikel gefreut, damit ich ein paar neue Dinge über effiziente Repräsenntation von Bitmaps lernen könnte.
Und dann ist alles was darin geschieht einfach nur gesunder Menschenverstand und ein paar Brot-und-Butter Algorithmen, gar keine Raketenwissenschaft, schon etwas ernüchternd.

An einigen Stellen wäre es interessant spezielle optimierte Containertypen für bestimmte Bitmuster zu sehen.
Auch der Wechel von Containertypen sollte einer Hysterese unterliegen, damit an der Grenze von 4096 Werten kein ständiger Wechsel passiert und damit Speicherdruck aufgebaut wird.
Ich habe auch darüber nachgedacht, ob es nicht sinnvoll wäre, die 65536 verschiedenen Bitmaps einfach in der Bibliothek einmalig zu materialisieren in einem Objekt-Array mit sovielen Einträgen und dann nur einen Offset in diese Array pro Container zu speichern.
Dann kann bei Änderungen einfach auf einen anderen Container gezeigt werden und optimierte Repräsentationen genutzt werden.
Auch könnten Set-Operationen über eine Matrix abgebildet werden.

Alternativ könnten häufige Muster mit kürzeren Codes versehen werden und dann statt der vollen Long-Werte genutzt.

Aber wahrscheinlich ist die aktuelle Implementierung eine gute Balance zwischen Verwaltungsaufwand und Speichernutzung.
Und zuviel dynamische Verwaltung bringt auch oft die Cache-Line Effizienz und das Vorausladen von kontinuierlichen Speicherbereichen aus dem L3 Cache oder dem Hauptspeicher durcheinander.

TODO 4096 im Paper erklärt?

Aller Ernüchterung zum Trotz ist es schön zu sehen, dass es effiziente BitMap Implementierungen gibt, die jedenfalls im Bereich bis 4 Milliarden Einträge gut funktionieren, wie der JMH Test zeigt.

Es gibt auch 64 Bit Implementierungen für Roaring BitMaps, die dann sicher ein ähnlichen Präfix-Index auf eine Liste von Roaring-Bitmaps anwenden. 
Ggf könnte man auch den Präfix Index von 16 auf 24 oder 32 Bit erweitern und damit 40 bzw. 48 Bit abdecken.

=== Resourcen

* [BitmapIndexWiki] https://de.wikipedia.org/wiki/Bitmap-Index
* [JavaBitSet] https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/BitSet.html
* [BSBaldung] https://www.baeldung.com/java-bitset
* Bit Operationen (Interaktiv?)
* [RoaringBM] https://roaringbitmap.org/
* [RBMPaperOptimierung] https://arxiv.org/pdf/1603.06549.pdf (Lemire & Co)
* [RBMPaperDatenstruktur] https://arxiv.org/pdf/1402.6407.pdf
* [RBMPaperImplementierung] https://arxiv.org/pdf/1709.07821v4.pdf
* [RBM Intro] https://vikramoberoi.com/a-primer-on-roaring-bitmaps-what-they-are-and-how-they-work/
* [RBM Usecase] https://vikramoberoi.com/using-bitmaps-to-run-interactive-retention-analyses-over-billions-of-events-for-less-than-100-mo/
* [Hackers Delight] https://en.wikipedia.org/wiki/Hacker%27s_Delight  